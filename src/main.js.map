{"mappings":";;;;;;;;;;;;AAAA;;AAEA,iBAAiB;AACjB,MAAM,iDAAa,CAAA,GAAA,sCAAK,AAAD,EAAE,aAAa,CAAC,IAAI;AAE3C,SAAS,4CAAa;IACpB,OAAO,CAAA,GAAA,uBAAS,EAAE;AACpB;AAEA,+BAA+B;AAC/B,SAAS,gCAAU,OAAO,EAAE,SAAS,EAAE;IACrC,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,qBAAQ,AAAD,EAAE;IAEnC,MAAM,UAAU,CAAA,GAAA,wBAAW,AAAD,EACxB,CAAC,MAAQ;QACP,sFAAsF;QACtF,+FAA+F;QAC/F,SAAS,CAAC,YAAc;YACtB,MAAM,CAAC,WAAW,QAAQ,GAAG,QAAQ,KAAK;YAC1C,QAAQ,OAAO,CAAC,CAAC,KAAO;gBACtB,IAAI,OAAO,OAAO,YAChB,GAAG;YAEP;YACA,OAAO;QACT;IACF,GACA;QAAC;KAAQ;IAGX,OAAO;QAAC;QAAO;KAAQ;AACzB;AAEA,SAAS,uCAAiB,mBAAmB,EAAE,KAAK,EAAE,OAAO,EAAE;IAC7D,CAAA,GAAA,sBAAS,AAAD,EAAE,IAAM;QACd,oBAAoB,OAAO;IAC7B,GAAG;QAAC;QAAqB;QAAO;KAAQ;IAExC,kCAAkC;IAClC,CAAA,GAAA,sBAAQ,EACN,IAAM,IAAM;YACV,oBAAoB,IAAI,EAAE;QAC5B,GACA;QAAC;QAAqB;KAAQ;AAElC;AAEA,2BAA2B;AAC3B,SAAS,iDAA2B,cAAc,EAAE;IAClD,MAAM,WAAW,IAAI;IAErB,OAAO,CAAC,OAAO,UAAY;QACzB,MAAM,OAAO,UAAU,IAAI,GAAG,eAAe,SAAS,EAAE;QACxD,kEAAkE;QAClE,KAAK,OAAO,CAAC,CAAC,OAAS;YACrB,IAAI,CAAC,SAAS,GAAG,CAAC,SAAS,OAAO,SAAS,YACzC,SAAS,GAAG,CAAC,MAAM,KAAK;QAE5B;QAEA,mCAAmC;QACnC,SAAS,OAAO,CAAC,CAAC,aAAa,OAAS;YACtC,IAAI,CAAC,KAAK,QAAQ,CAAC,SAAS,OAAO,gBAAgB,YAAY;gBAC7D;gBACA,SAAS,MAAM,CAAC;YAClB,CAAC;QACH;IACF;AACF;AASA,cAAc;AACd,SAAS,0CAAU,QAAE,KAAI,UAAE,OAAM,QAAE,KAAI,iBAAE,cAAa,EAAE,EAAE;IACxD,MAAM,sBAAsB,iDAA2B;IACvD,MAAM,eAAe;IAErB,SAAS,MAAM;QACb,MAAM,CAAC,OAAO,QAAQ,GAAG,gCAAU,QAAQ;QAC3C,uCAAiB,qBAAqB,OAAO;QAE7C,MAAM,MAAM,KAAK,OAAO;QACxB,qBAAO,gCAAC,iCAAW,QAAQ;YAAC,OAAO;sBAAU;;IAC/C;IAEA,OAAO;AACT","sources":["src/model-update-view.tsx"],"sourcesContent":["import React, { useState, useEffect, useContext, useCallback } from \"react\";\n\n// msg triggering\nconst MsgContext = React.createContext(null);\n\nfunction useSendMsg() {\n  return useContext(MsgContext);\n}\n\n// state/effect update function\nfunction useUpdate(reducer, initState) {\n  const [state, setState] = useState(initState);\n\n  const sendMsg = useCallback(\n    (msg) => {\n      // we need to use the callback version of setState, because otherwise two calls in the\n      // same tick might lead to unexpected updates (i.e. incrementing problem pointing to old state)\n      setState((prevState) => {\n        const [nextState, effects] = reducer(msg, prevState);\n        effects.forEach((fx) => {\n          if (typeof fx === \"function\") {\n            fx(sendMsg);\n          }\n        });\n        return nextState;\n      });\n    },\n    [reducer]\n  );\n\n  return [state, sendMsg];\n}\n\nfunction useSubscriptions(manageSubscriptions, state, sendMsg) {\n  useEffect(() => {\n    manageSubscriptions(state, sendMsg);\n  }, [manageSubscriptions, state, sendMsg]);\n\n  // unbind subscriptions on unmount\n  useEffect(\n    () => () => {\n      manageSubscriptions(null, sendMsg);\n    },\n    [manageSubscriptions, sendMsg]\n  );\n}\n\n// subscriptions management\nfunction createSubscriptionsManager(mapStateToSubs) {\n  const lastSubs = new Map();\n\n  return (state, sendMsg) => {\n    const subs = state !== null ? mapStateToSubs(state) : [];\n    // if new value is there, subscribe and store unsubscribe function\n    subs.forEach((func) => {\n      if (!lastSubs.has(func) && typeof func === \"function\") {\n        lastSubs.set(func, func(sendMsg));\n      }\n    });\n\n    // if value is removed, unsubscribe\n    lastSubs.forEach((unsubscribe, func) => {\n      if (!subs.includes(func) && typeof unsubscribe === \"function\") {\n        unsubscribe();\n        lastSubs.delete(func);\n      }\n    });\n  };\n}\ntype SendMsgFn = () => void;\ntype Effect = (sendMsg: SendMsgFn) => void;\n\ntype Implementation<Model, Msg> = {\n  init: () => Model;\n  update: (model: Model, msg: Msg) => [Model, Effect[]];\n};\n\n// app factory\nfunction createApp({ init, update, view, subscriptions }) {\n  const manageSubscriptions = createSubscriptionsManager(subscriptions);\n  const initialState = init();\n\n  function App() {\n    const [state, sendMsg] = useUpdate(update, initialState);\n    useSubscriptions(manageSubscriptions, state, sendMsg);\n\n    const jsx = view(state, sendMsg);\n    return <MsgContext.Provider value={sendMsg}>{jsx}</MsgContext.Provider>;\n  }\n\n  return App;\n}\n\nexport { createApp, useSendMsg };\n"],"names":[],"version":3,"file":"main.js.map"}